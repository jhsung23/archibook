# 7. 신뢰할 수 없는 코드를 쓰면서 불변성 지키기

## 레거시 코드와 불변성

- 카피-온-라이트가 적용되지 않은 레거시 코드를 추가해야 하는 상황
- 추가된 함수를 호출하면 카피-온-라이트 원칙을 지킬 수 없고 현재 레거시를 고칠 수 없는 상황 → 방어적 복사 원칙을 사용하자

## 우리가 만든 카피-온-라이트 코드는 신뢰할 수 없는 코드와 상호작용해야 합니다

- 카피-온-라이트를 적용하지 않은 코드는 불변성을 지킬 수 없어 신뢰할 수 없음
- 그러나 요구사항을 구현하기 위해 안전하지 않은 코드를 써야 함
- 따라서 입력과 출력을 통해 안전지대(불변성이 지켜지는 구간)에 있는 코드와 데이터를 주고 받아야 함
- 그런데 안전지대 밖으로 나가는 데이터는 잠재적으로 바뀔 수 있음
  - 신뢰할 수 없는 코드가 데이터를 바꿀 수 있기 때문
- 신뢰할 수 없는 코드에서 안전지대로 들어오는 데이터도 잠재적으로 바뀔 수 있음
  - 신뢰할 수 없는 코드가 계속 데이터 참조를 가지기 때문
- 불변성을 지키면서 데이터를 주고받는 방법을 찾아야 함
  - 데이터가 바뀌는 것을 완벽히 막아주는 방어적 복사 원칙으로 해결

## 방어적 복사는 원본이 바뀌는 것을 막아줍니다

- 신뢰할 수 없는 코드와 데이터를 주고받는 문제를 푸는 방법은 복사본을 만드는 것
- 들어온 데이터로 깊은 복사본을 만들고 변경 가능한 원본은 버림
  - 신뢰할 수 있는 코드만 복사본을 쓰기 때문에 데이터는 바뀌지 않음
- 나가는 데이터로 깊은 복사본을 만들고 원본은 안전지대에서 보호
- 들어오고 나가는 데이터의 복사본을 만드는 것이 방어적 복사가 동작하는 방식
- 안전지대에 불변성을 유지하고 바뀔 수도 있는 데이터가 안전지대로 들어오지 못하도록 하는 것이 방어적 복사의 목적

## 방어적 복사 구현하기

```tsx
function add_item_to_cart(name, price) {
  // 생략
  var cart_copy = deepCopy(shopping_Cart); // 장바구니 값을 넘기기 전에 깊은 복사
  black_friday_promotion(cart_copy); // 복사한 값을 넘겨 원본이 변경되지 않음
  shopping_cart = deepCopy(cart_copy); // 변경된 값을 복사해서 사용
}
```

- black_friday_promotion() 함수는 카피-온-라이트가 적용되지 않아 전역변수인 shopping_cart를 그대로 넘기면 불변성이 깨짐
- 따라서 원본이 바뀌지 않도록 깊은 복사를 해서 함수에 넘김
- black_friday_promotion() 함수는 복사본을 직접 수정하기 때문에 복사본의 참조를 여전히 가지고 있음
  - 추후 black_friday_promotion() 함수에서 cart_copy 값을 바꾼다면 버그가 될 것
  - 다시 안전지대로 들어오는 데이터를 깊은 복사하여 전역변수를 교체해야 함

## 방어적 복사 규칙

### 규칙1: 데이터가 안전한 코드에서 나갈 때 복사하기

- 변경 불가능한 데이터가 신뢰할 수 없는 코드로 나갈 때
  1. 불변성 데이터를 위한 깊은 복사본을 만들고
  2. 신뢰할 수 없는 코드로 복사본을 전달

### 규칙2: 안전한 코드로 데이터가 들어올 때 복사하기

- 신뢰할 수 없는 코드에서 변경될 수도 있는 데이터가 들어온다면
  1. 변경될 수도 있는 데이터가 들어오면 바로 깊은 복사본을 만들어 안전한 코드로 전달
  2. 복사본을 안전한 코드에서 사용

## 신뢰할 수 없는 코드 감싸기

- 문제점
  - 나중에 방어적 복사를 왜 적용했는지(복사본을 왜 만든 것인지) 이유를 모를 수도 있음
  - black_friday_promotion() 코드가 다시 필요할 수도 있음
- 따라서 방어적 복사 코드를 분리해 새로운 함수로 만들어 두면 좋음
  ```tsx
  function add_titem_to_cart(name, price) {
    // 생략 ...
    shopping_cart = black_friday_promotion_safe(shopping_cart);
  }

  function black_friday_promotion_safe(cart) {
    var cart_copy = deepCopy(cart);
    black_friday_promotion(cart_copy);
    return deepCopy(cart_copy);
  }
  ```

## 방어적 복사가 익숙할 수도 있습니다

- 방어적 복사는 오래전부터 다른 곳에서 쓰던 일반적인 패턴임

### 웹 API 속에 방어적 복사

- 대부분의 웹 기반 API는 암묵적으로 방어적 복사를 함
- 클라이언트는 데이터를 인터넷을 통해 API로 보내고 응답받기 위해 직렬화 함
  - 이때 전송 및 응답하는 JSON 데이터는 깊은 복사본임
  - 서비스에 들어올 때와 나갈 때 데이터를 복사한 것
- 모듈이 서로 통신하기 위해 방어적 복사를 구현했다면 비공유 아키텍처라고 함

### 얼랭과 엘릭서에서 방어적 복사

- 얼랭에서 두 프로세스가 서로 메시지를 주고받을 때 수신자의 메일박스에 메시지가 복사됨
- 프로세스에서 데이터가 나갈 때도 데이터를 복사함
- 방어적 복사는 얼랭 시스템이 고가용성을 보장하는 핵심 기능

## 카피-온-라이트와 방어적 복사를 비교해 봅시다

### 카피-온-라이트

- 언제 쓰나요?
  - 통제할 수 있는 데이터를 바꿀 때
- 어디서 쓰나요?
  - 안전지대 어디서나 (카피-온-라이트가 불변성을 가진 안전지대를 만듦)
- 복사 방식
  - 얕은 복사 (상대적으로 적은 비용)
- 규칙
  1. 바꿀 데이터의 얕은 복사를 만든다
  2. 복사본을 변경한다
  3. 복사본을 리턴한다

### 방어적 복사

- 언제 쓰나요?
  - 신뢰할 수 없는 코드와 데이터를 주고받아야 할 때
- 어디서 쓰나요?
  - 안전지대의 경계에서 데이터가 오고 갈 때
- 복사 방식
  - 깊은 복사 (상대적으로 많은 비용)
- 규칙
  1. 안전지대로 들어오는 데이터에 깊은 복사를 만든다
  2. 안전지대에서 나가는 데이터에 깊은 복사를 만든다

## 깊은 복사는 얕은 복사보다 비쌉니다

- 깊응ㄴ 복사는 원본과 어떤 데이터 구조도 공유하지 않는 것이 얕은 복사와의 차이점
- 중첩된 모든 객체나 배열을 복사함
- 얕은 복사의 경우 바뀌지 않은 값은 원본과 복사본이 데이터를 공유함 (구조적 공유)

## 자바스크립트에서 깊은 복사를 구현하는 것은 어렵습니다

- Lodash 라이브러리에 있는 깊은 복사 함수를 쓰는 것을 추천
