# 6. 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기 (2)

## 불변 데이터 구조를 읽는 것은 계산입니다

- 변경 가능한 데이터를 읽는 것은 액션임
  - 변경 가능한 값을 읽을 때마다 다른 값을 읽을 수도 있기 때문
- 쓰기는 데이터를 변경 가능한 구조로 만듦
  - 쓰기는 데이터를 바꾸기 때문
- 어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터임
  - 쓰기를 모두 없앴다면 데이터는 생성 이후 바뀌지 않음
- 불변 데이터 구조를 읽는 것은 계산임
  - 어떤 데이터를 불변형으로 만들었다면 그 데이터에 모든 읽기는 계산임
- 쓰기를 읽기로 바꾸면 코드에 계산이 많아짐
  - 데이터 구조를 불변형으로 만들수록 코드에 더 많은 계산이 생기고 액션은 줄어듦

## 애플리케이션에는 시간에 따라 변하는 상태가 있습니다

### 모든 값을 불변형으로 만들더라도 시간에 따라 바뀌는 값을 다룰 수 있어야 함

- shopping_cart 전역변수는 장바구니가 바뀔때 shopping_cart 전역변수에 새로운 값을 할당함
- 따라서 shopping_cart는 항상 최신 장바구니를 나타냄
- 장바구니 값은 새 값으로 교체(swapping)됨
- 교체하는 방법은 함수형 프로그래밍에서 일반적으로 사용하는 방법
- 교체를 사용하면 되돌리기를 쉽게 구현할 수 있음

## 불변 데이터 구조는 충분히 빠릅니다

- 일반적으로 불변 데이터 구조는 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느림
- 하지만 불변 데이터 구조를 사용하면서 대용량의 고성능 시스템을 구현하는 사례는 많음
  - 불변 데이터를 일반 애플리케이션에서 쓰기 충분히 빠르다는 증거

### 언제든 최적화할 수 있습니다

- 애플리케이션을 개발할 때 예상하기 힘든 병목 지점이 항상 있음
- 그래서 성능 개선을 할 때는 보통 미리 최적화하지 않음
- 불변 데이터 구조를 사용하고 속도가 느린 부분이 있다면 그때 최적화

### 가비지 콜렉터는 매우 빠릅니다

- 대부분의 언어는 가비지 콜렉터 성능 개선을 위해 꾸준히 연구해 옴
- 우리는 이런 기술을 그냥 쓰면 됨

### 생각보다 많이 복사하지 않습니다

- 제품이 100개인 배열을 복사해도 참조만 복사됨
- 데이터 구조의 최상위 단계만 복사하는 것을 얕은 복사라고 함
  - 얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만듦
  - 이것을 구조적 공유라고 함

### 함수형 프로그래밍 언어에는 빠른 구현체가 있음

- 데이터 구조를 복사할 때 최대한 많은 구조를 공유함
- 그래서 더 적은 메모리를 사용하고 결국 가비지 콜렉터의 부담을 줄여줌

## 객체에 대한 카피-온-라이트

- 배열에 대한 카피-온-라이트와 같은 단계로 구현할 수 있음
- 배열은 .slice() 메서드로 복사본을 만들 수 있었으나 자바스크립트 객체에는 .slice() 메서드가 없음
- 자바스크립트에서 객체에 있는 모든 키와 값을 복사하려면 Object.assign()을 사용하면 됨

## 중첩된 쓰기를 읽기로 바꾸기

- 제품 이름으로 해당 제품의 가격을 바꾸는 동작은 쓰기 동작
- 이 동작은 중첩된 데이터 구조를 바꿔야 하는 동작임
- 중첩된 쓰기도 중첩되지 않은 쓰기와 같은 패연을 사용함
  - 복사본을 만들고 변경한 다음 복사본을 리턴하는 방식
  - 중첩된 항목에 또 다른 카피-온-라이트를 사용하는 부분만 다름
- 항목을 직접 변경하면 불변 데이터가 아님
  - 배열에 항목은 바뀌지 않지만 배열 항목이 참조하는 값은 바뀌기 때문
- 중첩된 모든 데이터 구조가 바뀌지 않아야 불변 데이터임
- 최하위부터 최상위까지 중첩된 데이터 구조의 모든 부분이 불변형이어야 함
- 중첩된 데이터의 일부를 바꾸려면 변경하려는 값과 상위의 모든 값을 복사해야 함

## 어떤 복사본이 생겼을까요?

- 장바구니(배열) 안에 제품(객체) 3개가 있고 그 중 티셔츠의 가격을 변경하려는 경우
  ```tsx
  function setPriceByName(cart, name, price) {
    var cartCopy = cart.slice(); // 배열 복사
    for (var i = 0; i < cartCopy.length; i++) {
      if (cartCopy[i].name === name) {
        cartCopy[i] = setPrice(cartCopy[i], price); // 반복하다가 티셔츠를 찾으면 setPrice()를 한 번만 부름
      }
    }
    return cartCopy;
  }
  function setPrice(item, new_price) {
    var item_copy = Object.assign({}, item); // 객체 복사
    item_copy.price = new_price;
    return item_copy;
  }
  ```
- 배열 하나와 객체 세 개에서 배열 하나와 객체 하나의 복사본이 생김
  - 나머지 객체 두 개는 복사하지 않은 상태
- 중첩된 데이터에 얕은 복사를 했기 때문 → 구조적 공유 발생

## 결론

- 자바스크립트에서는 카피-온-라이트 원칙을 직접 구현해야 함
- 다른 고민 없이 이 함수들을 사용하기 때문에 원칙이라 부름

## 요점 정리

- 함수형 프로그래밍에서 불변 데이터가 필요함
  - 계산에서는 변경 가능한 데이터에 쓰기를 할 수 없음
- 카피-온-라이트는 데이터를 불변형으로 유지할 수 있는 원칙임
  - 복사본을 만들고 원본 대신 복사본을 변경하는 것을 ㅁ라함
- 카피-온-라이트는 값을 변경하기 전에 얕은 복사를 하고 리턴함
  - 통제할 수 있는 범위에서 불변성을 구현할 수 있음
- 보일러 플레이트 코드를 줄이기 위해 기본적인 배열과 객체 동작에 대한 카피-온-라이트 버전을 만들어 두는 것이 좋음
