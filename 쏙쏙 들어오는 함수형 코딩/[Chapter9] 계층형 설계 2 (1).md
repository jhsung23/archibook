# 9. 계층형 설계 2 (1)

## 패턴 2: 추상화 벽

- 추상화 벽은 여러가지 문제를 해결함
- 그 중 하나는 팀 간 책임을 명확하게 나누는 것

## 추상화 벽으로 구현을 감춥니다

- 추상화 벽은 세부 구현을 감춘 함수로 이루어진 계층
- 추상화 벽에 있는 함수를 사용할 때는 구현을 전혀 몰라도 함수를 쓸 수 있음
- 함수형 프로그래머는 문제를 높은 수준으로 생각하기 위해 추상화 벽을 효과적인 도구로 사용함

## 세부적인 것을 감추는 것은 대칭적입니다

- 추상화 벽을 사용하면 마케팅팀이 세부 구현을 신경쓰지 않아도 됨
- 신경쓰지 않아도 된다는 것은 대칭적임
- 추상화 벽을 만든 개발팀은 추상화 벽에 있는 함수를 사용하는 마케팅 관련 코드를 신경 쓰지 않아도 됨
- 추상화 벽이 잘 동작한다면 장바구니 데이터 구조를 변경하더라도 마케팅팀 코드를 바꾸지 않아도 될 것

## 장바구니를 객체로 다시 만들기

- 장바구니를 객체로 만들면 더 효율적이고 첫 번째 패턴인 직접 구현 패턴에 가까워짐
- 배열보다 객체가 어떤 위치에 추가하거나 삭제학 좋음
- 잘못 선택한 데이터 구조가 때로는 더 어려운 코드를 만들 수 있음

## 추상화 벽이 있으면 구체적인 것을 신경 쓰지 않아도 됩니다

### 장바구니 동작을 쓰는 함수를 전부 바꾸지 않고 어떻게 데이터 구조를 바꿀 수 있었나요?

- 데이터 구조를 변경하기 위해 함수 다섯 개만 바꿀 수 있었던 것은 바꾼 함수가 추상화 벽에 있는 함수이기 때문
- 추상화 벽은 ‘어떤 것을 신경 쓰지 않아도 되지?’라는 말을 거창하게 표현한 개념
- 계층 구조에서 어떤 계층에 있는 함수들이 장바구니와 같이 공통된 개념을 신경 쓰지 않아도 된다면 그 계층을 추상화 벽이라고 할 수 있음
- 추상화 벽은 필요하지 않은 것은 무시할 수 있도록 간접적인 단계를 만듦

```
remove_item_by_name()
calc_total()
isInCart()
add_item()
setPriceByName()

- 위 함수를 호출할 때는 장바구니가 어떤 데이터 구조로 이루어졌는지 알 필요가 없음
- 그저 함수만 사용하면 될 뿐 장바구니 구현에 대해서는 신경 쓰지 않아도 됨
```

## 추상화 벽은 언제 사용하면 좋을까요?

- 추상화 벽으로 좋은 설계를 만들 수 있지만 모든 곳에 추상화 벽을 사용하면 안 됨

### 1. 쉽게 구현을 바꾸기 위해

- 구현에 대한 확신이 없는 경우 추상화 벽을 사용하면 구현을 간접적으로 사용할 수 있기 때문에 나중에 구현을 바꾸기 쉬움
- 프로토타이핑과 같이 최선의 구현을 확신할 수 없는 작업에 유용함
- 또는 서버에서 데이터를 받아 처리해야 하지만 아직 준비가 되지 않은 경우처럼 뭔가 바뀔 것을 알고 있지만 아직 준비되지 않은 경우에도 유용함
- 하지만 만약을 대비해 코드를 만드는 것(불필요한 코드를 작성하는 것)은 좋지 않은 습관임

### 2. 코드를 읽고 쓰기 쉽게 만들기 위해

- 추상화 벽을 사용하면 세부적인 것을 신경 쓰지 않아도 됨
- 구체적인 것이 버그를 만들 수 있기 때문
- 반복문을 쓸 때 초기화 값, 종료 조건 등 세부적인 것을 신경 쓰지 않고 쉽게 코드를 만들 수 있음
- 적절한 것을 감추면 생선적인 코드를 만들 수 있음

### 3. 팀 간에 조율해야 할 것을 줄이기 위해

- 각 팀에 관한 구체적인 내용을 서로 신경 쓰지 않아도 빠르게 일할 수 있음
  - 마케팅팀은 개발팀이 작업한 장바구니의 데이터 구조가 무엇인지 몰라도 됨
  - 개발팀은 장바구니의 데이터 구조를 변경하더라도 마케팅에게 알리지 않아도 됨

### 4. 주어진 문제에 집중하기 위해

- 추상화 벽을 사용하면 해결하려는 문제의 구체적인 부분을 무시할 수 있음

## 패턴 2 리뷰: 추상화 벽

- 추상화 벽으로 추상화 벽 아래에 있는 코드와 위에 있는 코드의 의존성을 없앨 수 있음
- 서로 신경 쓰지 않아도 되는 구체적인 것을 벽을 기준으로 나눠서 서로 의존하지 않게 함
- 추상화 단계의 상위에 있는 코드와 하위에 있는 코드는 서로 의존하지 않게 정의함
- 추상화 단계의 모든 함수는 비슷한 세부 사항을 무시할 수 있도록 정의함
- 바뀌지 않을지도 모르는 코드를 언젠가 쉽게 바꿀 수 있게 만들려는 함정에 빠지지 않아야 함
  - 코드를 쉽게 고치려고 추상화 벽을 사용하는 것이 아니라, 팀 간 커뮤니케이션 비용을 줄이고 복잡한 코드를 명확하게 하기 위해 전략적인 사용이 필요

## 패턴 3: 작은 인터페이스

- 작은 인터페이스 패턴은 새로운 코드를 추가할 위치에 관한 것
- 인터페이스를 최소화하면 하위 계층에 불필요한 기능이 쓸데없이 커지는 것을 막을 수 있음

### 마케팅팀에서 시계를 할인하려고 합니다

- 장바구니에 제품을 많이 담은 사람이 시계를 구입하면 10% 할인
  ```
  if (장바구니 총합 > $100 && 장바구니에 시계 있음){
  	시계를 10% 할인
  }
  ```

### 시계 할인 마케팅을 구현하기 위한 두 가지 방법

- 추상화 벽에 구현 vs 추상화 벽 위에 있는 계층에 구현
  ```
  ├── gets_free_shipping()
  ├── cartTax()
  ├── <--여기: 추상화 벽 위에 만들기-->
  ├────── calc_total
  ├────── isInCart()
  ├────── add_item()
  ├────── setPriceByName()
  └────── <--여기: 추상화 벽에 만들기-->
  ```
- 방법 1: 추상화 벽에 만들기
  - 추상화 벽 계층에 있으면 해시 맵 데이터 구조로 되어 있는 장바구니에 접근할 수 있음
  - 하지만 같은 계층에 있는 함수를 사용할 수 없음
  ```jsx
  function getsWatchDiscount(cart) {
    var total = 0;
    var names = Object.keys(cart);
    for (var i = 0; i < names.length; i++) {
      var item = cart[names[i]];
      total += item.price;
    }
    return total > 100 && cart.hasOwnProperty('watch');
  }
  ```
- 방법 2: 추상화 벽 위에 만들기
  - 추상화 벽 위에 만들면 해시 데이터 구조를 직접 접근할 수 없음
  - 추상화 벽에 있는 함수를 사용해서 장바구니에 접근해야 함
  ```
  function getsWatchDiscount(cart) {
    var total = calcTotal(cart);
    var hasWatch = isInCart('watch');
    return total > 100 && hasWatch;
  }
  ```

### 추상화 벽 위에 있는 계층에 구현하는 것이 더 좋습니다

- 추상화 벽 위에 있는 계층에 만드는 것이 더 직접 구현에 가까움
- 추상화 벽에 만들 경우 시스템 하위 계층 코드가 늘어나기 때문에 좋지 않음
- 방법 1의 경우
  - 호출 화살표가 장벽을 건너지 않기 때문에 추상화 벽을 유지할 수 있음
  - 그러나 반복문 같은 구체적인 구현에 신경 써야 하기 때문에 추상화 벽 아래 위치해야 하고 개발팀에서 관리해야 함
- 새로운 기능을 만들 때 하위 계층에 기능을 추가하거나 고치는 것보다 상위 계층에 만드는 것이 작은 인터페이스 패턴이라 할 수 있음

### 마케팅팀은 장바구니에 제품을 담을 때 로그를 남기려고 합니다

- 데이터베이스에 로그를 기록하는 코드 logAddToCart(user_id, item)를 add_item() 함수에서 호출하는 것을 제안
  ```jsx
  function add_item(cart, item) {
    logAddToCart(global_user_id, item);
    return objectSet(cart, item.name, item);
  }
  ```

### 코드 위치에 대한 설계 결정

- add_item() 함수에서 호출하는 것은 문제가 없어보임
  - 장바구니에 제품을 담을 때마다 로그를 남길 수 있음
  - 상위 계층에서는 이 함수를 사용할 때 로그가 남고 있다는 구체적인 내용을 몰라도 됨
- 그러나 복잡하고 어려운 문제가 있음
- logAddToCart() 함수는 액션이기 때문에 add_item() 함수도 액션이 되고, 이를 호출하는 모든 함수가 액션이 되면서 액션이 전체로 퍼져 테스트하기 어려워짐
- 위치를 결정할 때 가장 중요한 요소는 장바구니에 관한 인터페이스를 깔끔하게 유지해야 하는 점
- logAddToCart() 함수는 추상화 벽 위에 있는 계층에서 호출하는 것이 좋음

### 장바구니 로그를 남길 더 좋은 위치

- 장바구니에 제품을 담을 때 호출하는 핸들러인 add_item_to_cart() 함수에서 호출

## 패턴 3 리뷰: 작은 인터페이스

- 추상화 벽에 만든 함수는 인터페이스라고 생각할 수 있음
- 추상화 벽에 있는 인터페이스로 어떤 값의 집합에 접근하거나 값을 조작할 수 있음
- 계층형 설계에서 완전한 추상화 벽과 최소한의 인터페이스 사이에 유연하게 조율해야 하는 점이 있음
