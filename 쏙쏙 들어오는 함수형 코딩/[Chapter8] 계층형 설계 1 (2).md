# 8. 계층형 설계 1 (2)

## 3단계 줌 레벨

### 1. 전역 줌 레벨

- 그래프 전체 중 필요한 부분을 살펴볼 수 있음
- 기본 줌 레벨
- 계층 사이에 상호 관계를 포함해서 모든 문제 영역을 살펴볼 수 있음

### 2. 계층 줌 레벨

- 한 계층과 연결된 바로 아래 계층을 볼 수 있는 줌 레벨
- 계층이 어떻게 구현되어 있는지 알 수 있음

### 3. 함수 줌 레벨

- 함수 하나와 바로 아래 연결된 함수들을 볼 수 있음
- 함수 구현의 문제를 찾을 수 있음

### 계층 줌 레벨로 보면 함수가 가리키는 화살표를 계층 간에 비교할 수 있습니다

- 계층에 집중해 보면 계층에 있는 모든 함수와 직접 호출하는 함수를 모두 볼 수 있음
- 직접 구현 패턴을 사용하면 모든 화살표가 같은 길이를 가져야 함
- 다양한 계층을 넘나드는 것은 같은 구체화 수준이 아니라는 증거

### 함수 줌 레벨을 사용하면 함수 하나가 가진 화살표를 비교할 수 있습니다

```
remove_item_by_name()
├── removeItems()
├────── array index
└────── for loop
```

- remove_item_by_name() 함수는 서로 다른 계층의 동작을 사용함
  - 이는 직접 구현 패턴에 맞지 않음
  - 직접 구현을 적용하면 모두 같은 길이의 화살표를 가져야 함
    - 즉, 동일한 계층을 참조해야 함
- 중간에 함수를 두면 긴 화살표를 줄일 수 있음
  - removeItems() 함수와 같은 계층에 반복문과 배열 인덱스 참조를 담당하는 함수를 만들면 됨

```
remove_item_by_name()
├── removeItems()
└── new_function()
		├── array index
		└── for loop
```

## 반복문 빼내기

### remove_item_by_name() 함수에서 반복문을 빼서 새로운 함수로 만들기

```jsx
// BEFORE
function remove_item_by_name(cart, name) {
  var idx = null;
  for (var i = 0; i < cart.length; i++) {
    if (cart[i].name === name) {
      idx = i;
    }
  }
  if (idx !== null) {
    return removeItems(cart, idx, 1);
  }
  return cart;
}
```

```jsx
// AFTER
function remove_item_by_name(cart, name) {
  var idx = indexOfItem(cart, name);
  if (idx !== null) {
    return removeItems(cart, idx, 1);
  }
  return cart;
}

function indexOfItem(cart, name) {
  for (var i = 0; i < cart.length; i++) {
    if (cart[i].name === name) {
      return i;
    }
    return null;
  }
}
```

```
remove_item_by_name()
├── removeItems()
└── indexOfItem()
		├── array index
		└── for loop
```

## 직접 구현 패턴 리뷰

### 직접 구현한 코드는 한 단계의 구체화 수준에 관한 문제만 해결합니다

- 코드가 서로 다른 구체화 단계에 있다면 읽기 어려움

### 계층형 설계는 특정 구체화 단계에 집중할 수 있게 도와줍니다

- 코드에 있는 다양한 단서를 통해 구체화 수준에 집중하다 보면 설계 감각을 키울 수 있고 코드를 필요에 알맞게 바꿀 수 있음

### 호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여줍니다

- 호출 그래프는 함수가 서로 어떻게 연결되어 있는지 보여줌
- 함수 시그니처와 본문, 호출 그래프와 같은 다양한 단서를 가지고 직접 코드 패턴을 적용할 수 있음

### 함수를 추출하면 더 일반적인 함수로 만들 수 있습니다

- 함수에 직접 구현 패턴을 적용하는 방법의 하나는 함수가 더 구체적인 내용을 다루지 않도록 함수를 일반적인 함수로 빼내는 것
- 일반적인 함수는 보통 구체적인 내용 하나만 다루기 때문에 테스트하기 쉬움
- 명확한 코드와 알맞은 이름을 가진 함수는 더 읽기 쉬움

### 일반적인 함수가 많을수록 재사용하기 좋습니다

- 함수로 빼내면 재사용할 수 있는 곳이 보임
- 중복 코드를 찾기 위해 함수를 빼내는 것과는 다름
- 구현을 명확하게 하기 위해 일반적인 함수를 빼내는 것
- 일반적인 함수는 구체적인 함수보다 더 많은 곳에서 쓸 수 있음

### 복잡성을 감추지 않습니다

- 직접 구현 패턴을 적용한 코드처럼 보이게 만드는 것은 쉬움
- 명확하지 않은 코드를 감추기 위해 도우미 함수를 만들면 됨
- 하지만 이렇게 하는 것은 계층형 설계가 아님
- 계층형 설계에서 모든 계층은 바로 아래 계층에 의존해야 함
